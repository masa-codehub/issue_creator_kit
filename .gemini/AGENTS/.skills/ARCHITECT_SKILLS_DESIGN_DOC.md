# スキル: Design Doc作成 (Detailed Design)

**ビジネス要求や既存機能の大規模なリファクタリングを具体的なシステム構造やデータフローに落とし込み、実装の SSOT となる Design Doc を作成するためのプロセスです。**

このドキュメントは、SYSTEM_ARCHITECT が `~/.gemini/GEMINI.md` の「プロジェクト進行フレームワーク（State Machine）」を実行する際に参照するデータソースです。

---

## 1. Planning Phase Inputs (for State 1)

計画策定時に、以下の情報を「能動的偵察 (Active Reconnaissance)」によって収集し、Todoリストの具体化に利用してください。

### 1.1 能動的偵察 (Active Reconnaissance)
*   **前提の確認:** `read_file("docs/system-context.md")` と関連 ADR を読み込み、システムの境界や外部依存関係への影響を特定する。
*   **既存仕様の再確認:** `glob` で関連する詳細設計書（Specs）をリストアップして読み込み、干渉を整理する。
*   **現場の証拠収集:** `search_file_content` で修正対象のドメインロジックやデータモデル (`models.py` 等) の現状を把握し、ドキュメントとの乖離を特定する。
*   **技術標準の特定:** `glob` で `middleware`, `config`, `docker-compose` 等を調査し、エラー処理やリトライポリシーの現状ルールを確認する。

### 1.2 作業ブランチの計画
*   **Action:** `~/.gemini/GEMINI.md` の **「1. Gitによるバージョン管理」** に従い、作業用ブランチを作成するタスクをTodoの先頭に追加する。

### 1.3 リスク評価 (Specific Context)
`~/.gemini/GEMINI.md` の 「3. プロジェクト進行 > 3. リスク評価」を参照し、本機能特有の以下の観点を重点的に評価してください。

*   **価値 (Value):** ユーザーはこの機能を本当に望んでいるか？アウトカム（良い変化）は明確か？
*   **実現可能性 (Feasibility):** 既存のデータ構造やインフラで無理なく、期間内に実装可能か？ データ整合性（トランザクション境界等）の要件は明確か？
*   **ユーザビリティ (Usability):** 開発者にとって理解しやすく拡張しやすいか？（APIの直感性、既存パターンとの整合性）
*   **ビジネス生存性 (Viability):** 法務・セキュリティ・財務的観点で問題ないか？ 技術的負債を悪化させないか？

### 1.4 観察結果の統合とドラフト作成 (Observe & Draft)
*   調査結果とリスク評価を統合し、新機能が解決すべき「真のペイン」と、期待されるアウトカムを言語化する。
*   `~/.gemini/GEMINI.md` の **「2. ファイル操作」** に従い、ドラフトを作成する（ステータス: `下書き`）。
    *   **Rule:** 「背景と課題」「ゴール」セクションのみを詳細に記述すること。

---

## 2. Execution Phase Actions (for State 2)

Todoを実行する際、以下の思考プロセスと記述ガードレールを遵守してください。

### 2.1 ドメインモデリングと実現方式の検討 (Thinking Process)
いきなり詳細を書かず、以下の順で方針を固め、チャット上に出力します。

1.  **ドメイン分析:**
    ```
    === ドメイン分析 ===
    【境界づけられたコンテキスト】 影響を受ける範囲（既存コンテキストへの影響含む）
    【主要な集約 (Aggregate) / エンティティ】 今回導入・変更されるデータのまとまり
    【データの整合性】 トランザクション境界や結果整合性の要件 (Martin Kleppmann)
    【ユビキタス言語の更新】 今回の設計で導入・再定義される重要なキーワード
    【ドメイン層の責務】 この機能が解決すべきビジネスロジックの核心
    ```
2.  **実現方式の比較検討 (Mark Richards):** 複数の解を比較し、トレードオフを明確にする。
    ```
    === 実現方式の比較検討 ===
    | オプション | メリット (得られる特性) | デメリット (犠牲になる特性) |
    | :--- | :--- | :--- |
    | A案 (推奨) | ... | ... |
    | B案 (代替) | ... | ... |
    ```
3.  **判断分岐 (ADR):** システム全体に関わる重大な技術選定が必要と判断した場合、作業を中断し、ユーザーに「ADR の作成」を提案する。

### 2.2 アーキテクチャ仮説の言語化 (Hypothesis)
**目的: 決定した設計アプローチを「検証可能な仮説」として明文化し、4 大リスクとトレードオフの観点からその妥当性を客観的に評価するため。**
決定したアプローチを以下のテンプレートで整理し、チャット上に出力して方針を確定させます。

```
【ビジネス上の意図】 実現したい真のアウトカム
【技術的な方向性】 選択した設計思想と採用したオプション
【期待される効果】 4 大リスクへのポジティブな影響
【主要なトレードオフ】 この選択によって犠牲になる特性
【反証の想定】 この設計が誤りであった場合に顕在化するリスク
```

**アウトプット例 (記述レベル感):**
- **## 概念モデル (ドメイン構造):**
    - `【Draft Issue】: 依存関係メタデータを持つ未発行タスク。src/ への実装指示を含む。`
    - `【Dynamic Resolver】: 実行時にファイル参照を GitHub Issue 番号へ置換するコンポーネント。`
- **## 非機能要件 (信頼性の方針):**
    - `[Fail-Fast]: API レート制限が不足している場合、1件も Issue を作らずに即座に異常終了させる。`

### 2.3 整合性の検証と構造の可視化 (Verify & Visualize)
ファイル更新の前に、既存資産との最終的な整合性確認と構造の可視化を行います。

1.  **整合性チェック:** `~/.gemini/GEMINI.md` の **「2. SSOT精査と整合性検証プロトコル」** を実行。既存の `system-context.md` や ADR と矛盾がないことを確実にする。
2.  **構造図の作成:** `mermaid` を用いて、コンポーネント間の関係やデータフロー（C4 モデル Level 2 相当）を定義する。

### 2.4 Design Doc への初期反映 (Update)
以上の Step 2.1〜2.3 で確定した情報を `~/.gemini/GEMINI.md` の **「2. ファイル操作」** に従い、Design Doc にまとめて反映させます。
*   **Action:** 「概念モデル」「アーキテクチャ設計」「検討した代替案」を最新の状態に更新し、Mermaid 図を埋め込む。

### 2.5 詳細設計: データモデルと永続化 (Data & Persistence)
**Martin Kleppmann** の視点に基づき、データの信頼性と整合性を担保する設計を行います。

1.  **既存データ定義の把握:** 以下のコマンドを実行して既存のモデルを網羅的に把握し、集約範囲との整合性を確認する。
    `glob(pattern="**/{models.py,schema.prisma,*.sql,entities.py,tables.py}")`
    （ヒットしたファイルを `read_file` で読み込み、集約範囲との整合性を確認する）
2.  **ER 図の記録:** `mermaid` (erDiagram) でエンティティ関係を定義し、Design Doc に追記する。
    **ER 図の見本:**
    ```mermaid
    erDiagram
        USER ||--o{ POST : "writes"
        USER { string id PK "UUID" string email "Unique" }
        POST { string id PK string body string author_id FK }
    ```

### 2.6 詳細設計: インターフェースと振る舞い (Interface & Behavior)
**Clean Architecture** に従い、外部インターフェースとドメインの振る舞いを定義します。

1.  **API 定義の設計:** 以下のコマンドで既存のエンドポイントや型定義を特定し、プロジェクトの設計規則（URL, レスポンス形式等）を把握する。
    `glob(pattern="**/{routes,controllers,api,views,routers}/**/*.{ts,py,go,js}")`
    `glob(pattern="**/{schemas,dtos,types,models}/**/*.{ts,py,go,js}")`
2.  **API定義の記録:** エンドポイント、リクエスト/レスポンス詳細を追記する。
    **API 定義の見本:**
    ```markdown
    ### `POST /api/v1/posts`
    - **Request:** `{ "title": "...", "body": "..." }`
    - **Response:** `201 Created`
    ```
3.  **動的フローの記録:** 正常系だけでなく例外系も含め、データの流れを `mermaid` (sequenceDiagram) で可視化して追記する。
    **シーケンス図の見本:**
    ```mermaid
    sequenceDiagram
        Client->>API: POST /posts
        API->>Domain: Create Post
        Domain-->>API: Result
        API-->>Client: 201 Created
    ```

### 2.7 非機能要件と信頼性 (Non-Functional & Reliability)
**4 大リスク（特にビジネス生存性）** を担保します。

1.  **品質特性の方針策定:** 以下のコマンドで既存のインフラ構成を調査し、標準的なエラー処理やタイムアウト設定を特定する。
    `glob(pattern="**/{middleware,interceptors,auth,security,config,settings}/**/*.{ts,py,go,js}")`
    `search_file_content(pattern="retry|timeout|rate_limit|circuit_breaker")`
2.  **記録:** 実装者が準拠すべきルールを明文化して追記する。
    **記述見本:**
    ```markdown
    ### 非機能要件
    - **エラー処理:** 外部サービス接続エラーは、指数バックオフで最大 3 回リトライする。
    - **整合性:** 決済処理は強力な整合性（ACID）を必須とする。
    ```

### 2.8 代替案と進化性の評価 (Alternatives & Evolution)
**Mark Richards & Martin Fowler** の視点で、設計の妥当性を証明します。

1.  **トレードオフ分析:** 推奨案に対する代替案を比較し、Markdown Table で整理する。
2.  **進化性の検証:** 将来の拡張シナリオ（MVP後の追加要件等）に対する耐性を記述する。

### 2.9 Design Doc への一括反映 (Update)
Step 2.5〜2.8 で確定した詳細設計情報を Design Doc に反映させます。

### 2.10 自己レビューと論点抽出 (Self-Review Loop)
合意形成前に、`~/.gemini/GEMINI.md` の **「SSOT精査と整合性検証プロトコル」** を実行して作成したドラフトの品質を監査します。

1.  **Fresh Read:** 作成中の Design Doc と SSOT (`system-context.md` 等) を突き合わせる。
2.  **チェックリスト:**
    *   **[アウトカム適合性]** Step 1 で定義した「真の課題」を確実に解決できるか？
    *   **[クリーンアーキテクチャ]** ビジネスロジックが適切に隔離されているか？
    *   **[内部整合性]** ER図、API定義、シーケンス図の間で矛盾はないか？
    *   **[検証基準]** 実装担当が迷わずテストを書けるほど具体的か？
3.  **論点整理:** ユーザーに確認が必要な箇所に `[要検討: 内容]` タグを付与し、`save_memory` に論点を記録する。
    - **記述の具体性:** 単なる単語ではなく、背景（不整合の懸念など）と具体的な質問案を併記する。
    - **コマンド例:** `save_memory(fact="[Design-XXX] 論点TODO: [ ] 1.エラー時のUI表示(APIエラー時にトーストを表示するか、専用のEmpty Stateを表示するか確認)...")`

### 2.11 合意形成ループ (Decide)
論点リストに基づき、以下のループで収束させます。

1.  **合意形成ループの実行:**
    - **A. 最小単位の問いかけ:**
        - **TODO の呼び出し:** `save_memory` から優先度の高い項目を選択する。
        - **アウトカムに基づく問いかけ:** 「この挙動は当初のアウトカムを達成できるか？」「4 大リスク（特にユーザビリティ）への影響はどうか？」という視点を交え、具体的な画面遷移や例外系の振る舞いをユーザーに問いかける。
    - **B. Design Doc の同期と提示:**
        - `~/.gemini/GEMINI.md` の **「2. ファイル操作」** に従い、`replace` で即座に更新する。
        - **更新の明示:** どの箇所（ER図、API定義等）をどのように書き換えたのか（Before/After または要約）を明示し、確認を促す。
    - **C. リストの更新:** 解決した論点を消し込む (`[x]`)。
    - **D. 整合性と一貫性の監視:**
        - **矛盾の検知:** 最新の回答が、既存の ADR、システムコンテキスト、あるいは Design Doc 内の他の定義と矛盾していないか常に監視する。
        - **警告と提案:** 矛盾を検知した場合は「設計の一貫性が損なわれるリスク」を具体的に説明し、代替案を提示して再確認を行う。

2.  **根本的理解の不一致への対応:**
    - 前提が覆った場合は、**ループを中断し、躊躇なく Step 1.1（観察・調査）に立ち戻り、コンセプトからやり直す。**
    - **メモリの破棄:** 立ち戻る際、`save_memory(fact="[Design-XXX] 論点TODO: (廃棄済み・再構築中)")` を実行すること。

3.  **ループの終了（完了判定）:**
    - 全ての論点が `[x]` となり、内容および **「検証基準」** に合意が得られた時点で、このフェーズを完了とする。
    - **ステータスの更新:** `replace` を用い、Design Doc の `Status` を `承認済み` に更新する。
    - **メモリのクリーンアップ:** `save_memory(fact="[Design-XXX] 論点TODO: (全て解消・完了)")` を実行する。

---

## 3. Closing Phase Criteria (for State 3)

タスク完了時に、以下の手順で最終監査を行い、品質を保証してください。

### 3.1 最終監査 (Final Audit)
以下の手順で成果物を精査し、自信を持って「Yes」と回答できるか確認します。

1.  **成果物の再読:** `read_file` で完成した Design Doc を読み込む。
2.  **整合性の再検証:** `~/.gemini/GEMINI.md` の「SSOT精査プロトコル」に基づき、全体方針との矛盾がないか最終確認する。
3.  **チェックリストの消込:**
    *   **[アウトカム適合性]** 期待される「アウトカム」を確実に達成できるか？
    *   **[DDD/境界]** 境界づけられたコンテキストが明確で、他の集約を破壊していないか？
    *   **[クリーンアーキテクチャ]** 依存性のルールが守られ、ビジネスロジックが適切に隔離されているか？
    *   **[4 大リスク]** 実装に進むにあたり、実現可能性や生存性に致命的な懸念はないか？
    *   **[内部整合性]** 図面と記述の間で矛盾がないか？
    *   **[検証基準]** 実装担当が迷わずテストコードを記述できるほど、具体的かつ客観的な「検証基準」が記述されているか？
    *   **[SSOT]** 背景（Why）と詳細設計（How）が、実装者に迷いなく伝わるか？

### 3.2 成果物の定着
`~/.gemini/GEMINI.md` の **「プルリクエストの管理 (PR Protocol)」** に従い、提出してください。
*   **PR Body:** 設計の核心（アーキテクチャ、データモデル）と、実装への引き継ぎ事項を要約する。

ビジネス要求や**既存機能の大規模なリファクタリング**を具体的なシステム構造やデータフローに落とし込み、実装の SSOT となる Design Doc を作成するためのプロセスです。

### Step 0: 事前準備

1.  **連番と命名の確認:** `run_shell_command(command="ls reqs/design/_inbox/ reqs/design/_approved/")` を実行し、次の連番（`XXX`）を確認する。

2.  **作業ブランチの作成:** `run_shell_command(command="git checkout -b feature/design-XXX-feature-name")` を実行する。

3.  **テンプレートの取得:** `read_file(file_path="reqs/design/template/design-doc.md")` を実行し、設計すべき構成要素を再確認する。

### Step 1: 顧客価値とアウトカムの深掘り (Observe)

1.  **既存仕様と実装状況の再確認:**

    1.  `read_file(file_path="docs/system-context.md")` を実行し、システムの境界や外部依存関係への影響を特定する。

    2.  `run_shell_command(command="ls reqs/design/_inbox/ reqs/design/_approved/")` で関連 ADR を特定し、過去および現在進行中の設計決定との整合性を確認する。

        3.  `glob(pattern="specs/**/*.md")` を実行し、関連ドキュメントをリストアップして読み込み、既存ユースケースとの干渉を整理する。

        4.  `search_file_content(pattern="<関連キーワード>", dir_path="src/")` を実行し、関連するドメインロジックや**修正対象のコード**の現状を把握し、ドキュメントとの乖離がないか確認する。

2.  **4 大リスクの初期評価:** 新機能特有のリスクを特定し、思考プロセスの冒頭に以下のテンプレートを出力して各項目を評価する。

**4 大リスク評価結果**

```

[価値: 評価(高/中/低)] 懸念理由とその詳細

[実現可能性: 評価(高/中/低)] 懸念理由とその詳細

[ユーザビリティ: 評価(高/中/低)] 懸念理由とその詳細

[ビジネス生存性: 評価(高/中/低)] 懸念理由とその詳細

```

- **価値 (Value):** ユーザーはこの機能を本当に望んでいるか？アウトカム（良い変化）は明確か？

- **実現可能性 (Feasibility):** 既存のデータ構造やインフラで無理なく、期間内に実装可能か？

- **ユーザビリティ (Usability):** 開発者にとって理解しやすく拡張しやすいか？

- **ビジネス生存性 (Viability):** 法務・セキュリティ・財務的観点で問題ないか？

3.  **観察結果の統合とドラフト作成:**

    1.  調査結果とリスク評価を統合し、新機能が解決すべき「真のペイン」と、期待されるアウトカムを言語化する。

    2.  `write_file(file_path="reqs/design/_inbox/design-XXX-feature.md", content="...")` を実行し、ドラフトを先行して作成する。

    3.  **ドラフト作成時のルール:** ステータスは `下書き` とし、日付を本日（YYYY-MM-DD）に設定、「背景と課題」「ゴール」セクションのみを詳細に記述すること。

### Step 2: ドメインモデリングとハイレベル設計 (Orient - 1)

1.  **ドメインモデルと技術オプションの分析 (Thinking Process):**
    - **いきなりファイルを更新せず、** 以下の 1.1 から 1.3 の順で思考プロセスを行い、その結果をチャット上に出力して自身の方針を固める。
    1.1. **ドメイン分析:** 以下のテンプレートを用いて、要求をドメインモデルに落とし込む。
    ```
    === ドメイン分析 ===
    【境界づけられたコンテキスト】 影響を受ける範囲（既存コンテキストへの影響含む）
    【主要な集約 (Aggregate) / エンティティ】 今回導入・変更されるデータのまとまり
    【データの整合性】 トランザクション境界や結果整合性の要件 (Martin Kleppmann)
    【ユビキタス言語の更新】 今回の設計で導入・再定義される重要なキーワード
    【ドメイン層の責務】 この機能が解決すべきビジネスロジックの核心
    ```
    1.2. **実現方式の比較検討 (Mark Richards):** 複数の解を比較し、トレードオフを明確にする。
    ```
    === 実現方式の比較検討 ===
    | オプション | メリット (得られる特性) | デメリット (犠牲になる特性) |
    | :--- | :--- | :--- |
    | A案 (推奨) | ... | ... |
    | B案 (代替) | ... | ... |
    ```
    1.3. **判断分岐 (ADR):** システム全体に関わる重大な技術選定が必要と判断した場合、ここで作業を中断し、ユーザーに「ADR の作成」を提案する。

2.  **アーキテクチャ仮説の言語化 (Hypothesis):**
    - 決定したアプローチを以下のテンプレートで整理し、チャット上に出力する。
    2.1. **仮説の明文化:** 4 大リスクとトレードオフを考慮した設計思想を記述する。
    ```
    【ビジネス上の意図】 実現したい真のアウトカム
    【技術的な方向性】 選択した設計思想と採用したオプション
    【期待される効果】 4 大リスクへのポジティブな影響
    【主要なトレードオフ】 この選択によって犠牲になる特性（パフォーマンス vs 保守性など）
    【反証の想定】 この設計が誤りであった場合に顕在化するリスク
    ```

**アウトプット例 (記述レベル感):**
- **## 概念モデル (ドメイン構造):**
    - `【Draft Issue】: 依存関係メタデータを持つ未発行タスク。src/ への実装指示を含む。`
    - `【Dynamic Resolver】: 実行時にファイル参照を GitHub Issue 番号へ置換するコンポーネント。`
- **## 非機能要件 (信頼性の方針):**
    - `[Fail-Fast]: API レート制限が不足している場合、1件も Issue を作らずに即座に異常終了させ、リポジトリの整合性を守る。`

3.  **整合性の検証と視覚化 (Verify & Visualize):**
    - ファイル更新の前に、既存資産との最終的な整合性確認と構造の可視化を行う。
    3.1. **整合性チェック:** `read_file` で `docs/system-context.md` や既存 ADR を確認し、矛盾がないことを確実にする。
    3.2. **構造図の作成:** `mermaid` を用いて、コンポーネント間の関係やデータフロー（C4 モデル Level 2 相当）を定義する。

4.  **Design Doc への一括反映 (Update):**
    - 以上の 1〜3 で確定した情報を `replace` を用いて Design Doc にまとめて反映させる。
    4.1. **セクション更新:** 「概念モデル」「アーキテクチャ設計」「検討した代替案」を最新の状態に更新する。
    4.2. **図の挿入:** 作成した Mermaid 図を適切な位置に埋め込む。

### Step 3: 詳細設計とトレードオフ分析 (Orient - 2)

1.  **データモデルと永続化 (Data & Persistence):**
    - **Martin Kleppmann** の視点に基づき、データの信頼性と整合性を担保する設計を行う。
    1.1. **ER 図の設計と記録:**
        1. **思考:** 以下のコマンドを実行して既存のデータ定義を網羅的に把握し、DDD の集約範囲と整合性を考慮してエンティティを設計する。
           `glob(pattern="**/{models.py,schema.prisma,*.sql,entities.py,tables.py}")`
           （ヒットした主要なファイルを `read_file` で読み込む）
        2. **記録:** `replace` を用い、`mermaid` (erDiagram) を Design Doc に追記する。
        **ER 図の見本:**
        ```mermaid
        erDiagram
            USER ||--o{ POST : "writes"
            USER { string id PK "UUID" string email "Unique" }
            POST { string id PK string body string author_id FK }
        ```

2.  **インターフェースと振る舞い (Interface & Behavior):**
    - **Clean Architecture** に従い、外部インターフェースとドメインの振る舞いを定義する。
    2.1. **API 定義の設計と記録:**
        1. **思考:** 以下のコマンドで既存のエンドポイント、ルーティング、型定義を特定し、プロジェクトの URL 設計規則や共通レスポンス形式を把握した上で、必要なリソースを定義する。
           `glob(pattern="**/{routes,controllers,api,views,routers}/**/*.{ts,py,go,js}")`
           `glob(pattern="**/{schemas,dtos,types,models}/**/*.{ts,py,go,js}")`
        2. **記録:** `replace` を用い、エンドポイント、リクエスト/レスポンス詳細を追記する。
        **API 定義の見本:**
        ```markdown
        ### `POST /api/v1/posts`
        - **Request:** `{ "title": "...", "body": "..." }`
        - **Response:** `201 Created`
        ```
    2.2. **動的フロー（シーケンス図）の設計と記録:**
        1. **思考:** 正常系だけでなく、例外発生時や境界を越えるデータの流れをシミュレーションする。
        2. **記録:** `replace` を用い、`mermaid` (sequenceDiagram) を追記する。
        **シーケンス図の見本:**
        ```mermaid
        sequenceDiagram
            Client->>API: POST /posts
            API->>Domain: Create Post
            Domain-->>API: Result
            API-->>Client: 201 Created
        ```

3.  **非機能要件と信頼性 (Non-Functional & Reliability):**
    - **4 大リスク（特にビジネス生存性）** を担保する。
    3.1. **品質特性の方針策定:**
        1. **思考:** 以下のコマンドで既存のミドルウェア、設定、インフラ構成を調査し、プロジェクト標準のエラー処理、認証フロー、タイムアウト設定等を特定する。**もし明確なポリシーが見つからない場合は、立ち止まらずに一般的なベストプラクティス（例: タイムアウト 30 秒、指数バックオフによるリトライ 3 回）を仮定案として採用する。**
           `glob(pattern="**/{middleware,interceptors,auth,security,config,settings}/**/*.{ts,py,go,js}")`
           `glob(pattern="**/{docker-compose*,k8s/*.yaml,Dockerfile}")`
           `search_file_content(pattern="retry|timeout|rate_limit|circuit_breaker")`
        2. **記録:** `replace` を用い、実装者が準拠すべきルールを明文化して追記する。
        **記述見本:**
        ```markdown
        ### 非機能要件
        - **エラー処理:** 外部サービス接続エラーは、指数バックオフで最大 3 回リトライする。
        - **整合性:** 決済処理は強力な整合性（ACID）を必須とする。
        ```

4.  **代替案と進化性の評価 (Alternatives & Evolution):**
    - **Mark Richards & Martin Fowler** の視点で、設計の妥当性を証明する。
    4.1. **トレードオフ分析:**
        1. **思考:** 推奨案に対する代替案（RDB vs NoSQL 等）を比較し、メリット・デメリットを整理する。
        2. **記録:** `replace` を用い、比較表 (Markdown Table) を「検討した代替案」セクションに追記する。
    4.2. **進化性の検証:**
        1. **思考:** 将来の変更（MVP 後の拡張）に対する耐性をシミュレーションする。
        2. **記録:** `replace` を用い、拡張シナリオと対応方針を追記する。

5.  **仕上げと整合性確認 (Finalize & SSOT):**
    - 設計全体の品質を担保し、実装フェーズへの確実な引き継ぎを行う。
    5.1. **自己レビューと論点抽出:**
        1. **情報の再取得と照合:** 以下のコマンドを実行し、設計内容を最新のコンテキストと突き合わせる。
           `read_file(file_path="reqs/design/_inbox/design-XXX-feature.md")` （作成中のファイル）
           `read_file(file_path="docs/system-context.md")`
           `glob(pattern="reqs/design/_inbox/*.md")` （関連する最新決定事項の特定）
        2. **思考 (Self-Review):** 読み込んだドキュメントを照合し、行動規範に基づいた以下のチェックリストで自己レビューを行う。
            - **[アウトカム適合性]** この詳細設計は、Step 1 で定義した「真の課題」を解決し、期待される「アウトカム」を確実に達成できるか？
            - **[クリーンアーキテクチャ]** 依存性のルールが守られ、ビジネスロジックが技術的詳細（API, DB）から適切に隔離されているか？
            - **[4 大リスクの再評価]** 詳細化した結果、実現可能性やユーザビリティ、ビジネス生存性に新たな懸念が生じていないか？
            - **[内部整合性]** ER図、API定義、シーケンス図、非機能要件の間で、データ名やフローに矛盾がないか？
            - **[検証基準の明文化]** 実装担当が「何を以て完了とするか」を判断できる、具体的なテストケースや検証基準が含まれているか？
        3. **記録:** `replace` を用い、不整合の修正を行う。また、ユーザーに確認が必要な箇所や、実装上のトレードオフが発生する箇所に `[要検討: 内容]` というタグを付記し、後続の Step 4 で議論すべき論点を整理する。

### Step 4: 合意形成ループ (Decide)

ユーザーとの対話を通じて Design Doc を動的に完成させるステップです。全ての論点が解消されるまで、以下の **「合意形成ループ」** を回し続けます。

1.  **論点（質問リスト）の初期化:**

    - Step 3 までの分析結果や、Step 3.5 で抽出した「要検討」事項に基づき、解消すべき論点や不確定要素を特定する。
    - `save_memory` を用いて、解決すべき項目を記録する。
    - **記述の具体性:** 単なる単語ではなく、後で思考を再現できるよう「なぜこれを確認する必要があるのか」「どのような挙動上の不整合を懸念しているのか」という背景と具体的な質問案を併記すること。
    - **コマンド例:** `save_memory(fact="[Design-XXX] 論点TODO: 1.エラー時のUI表示(APIエラー時にトーストを表示するか、専用のEmpty Stateを表示するか確認)...")`

2.  **合意形成ループの実行:**

    - **A. 最小単位の問いかけ:**
        - **TODO の呼び出し:** `save_memory` に記録した論点 TODO を確認し、現在の設計状況において最も優先度の高い項目（依存関係の上流にあるもの等）を一つ選択する。
        - **アウトカムに基づく問いかけ:** 「この挙動は当初のゴール（アウトカム）を達成できるか？」「4 大リスク（特にユーザビリティ）への影響はどうか？」という視点を交え、具体的な画面遷移やデータ項目、例外系の振る舞いをユーザーに問いかける。
    - **B. Design Doc の同期と提示:**
        - ユーザーの回答に基づき、`reqs/design/_inbox/design-XXX-feature.md` の該当セクションを `replace` で即座に更新する。
        - **置換のコツ:** ツール失敗を避けるため、`old_string` には十分なコンテキスト（3 行以上の前後行）を含めること。
        - **更新の明示:** ユーザーに対し、Design Doc のどの箇所（ER図、API定義、シーケンス図等）をどのように書き換えたのか（Before/After または要約）をチャット上で明示し、確認を促す。
    - **C. リストの更新:** 解決した論点を TODO リストから削除（消込）し、新たに判明した疑問があればリストに追加して `save_memory` を更新する。
    - **D. 整合性と一貫性の監視:**
        - **矛盾の検知:** ユーザーの最新の回答が、既存の ADR、システムコンテキスト、あるいは Design Doc 内の他の定義と矛盾していないか常に監視する。
        - **警告と提案:** 矛盾を検知した場合は「設計の一貫性が損なわれるリスク」を具体的に説明し、代替案を提示して再確認を行う。

3.  **根本的理解の不一致への対応:**

    - 対話の中で「機能の前提や目的が根本から覆る」ような事実が判明した場合は、**ループを中断し、躊躇なく Step 1（顧客価値の深掘り）に立ち戻り、コンセプトからやり直す。**
    - **メモリの破棄:** 立ち戻る際、`save_memory(fact="[Design-XXX] 論点TODO: (廃棄済み・再構築中)")` を実行し、古い TODO を無効化すること。

4.  **ループの終了（完了判定）:**

    - `save_memory` 内の全ての論点が解消され、最新の Design Doc の内容および **「検証基準 (Verification Criteria)」** に対してユーザーと合意・確信を共有できた時点で、このフェーズを完了とする。
    - **ステータスの更新:** `replace` を用い、Design Doc の `Status` を `下書き` や `レビュー中` から `承認済み` に、`Last Updated` を合意した日付に変更する。
    - **メモリのクリーンアップ:** 完了にあたり、`save_memory(fact="[Design-XXX] 論点TODO: (全て解消・完了)")` を実行し、メモリ上の作業リストを整理する。

### Step 5: SSOT の構築と最終監査 (Act)

1.  **最終監査 (Final Audit):**

    1.  **成果物の再読:** `read_file` を用いて、完成した `reqs/design/_inbox/design-XXX-feature.md` を読み込む。
    2.  **整合性の再検証:** `docs/system-context.md` や関連する ADR を再度読み込み、新機能の設計がシステム全体のアーキテクチャ方針や既存の決定事項と矛盾していないか、ユビキタス言語が厳密に統一されているかを精査する。
    3.  **チェックリストの消込:** 以下の項目に対し、自信を持って「Yes」と回答できるかを最終監査する。
        - **[アウトカム適合性]** この設計は、Step 1 で定義した「真の課題」を解決し、期待される「アウトカム」を確実に達成できるか？
        - **[DDD/境界]** 境界づけられたコンテキストが明確で、他の集約を不必要に破壊していないか？
        - **[クリーンアーキテクチャ]** 依存性のルールが守られ、ビジネスロジックが外部詳細（API, DB, Framework）から適切に隔離されているか？
        - **[4 大リスク]** 実装フェーズに進むにあたり、実現可能性やビジネス生存性に致命的な懸念は残っていないか？
        - **[内部整合性]** ER図、API定義、シーケンス図の間で、データ構造やフローに不一致がないか？
        - **[検証基準]** 実装担当が迷わずテストコードを記述できるほど、具体的かつ客観的な「検証基準」が記述されているか？
        - **[SSOT]** 背景（なぜ作るか）と詳細設計（どう作るか）が、実装を担当するエージェントに迷いなく伝わる記述になっているか？

2.  **コミットと PR の起票:**

    1.  **ステージングとコミット:**
        - `run_shell_command(command="git add reqs/design/_inbox/design-XXX-feature.md && git commit -m 'docs: Design Doc XXX (機能名) を承認済みとして作成'")` を実行する。
    2.  **PR の起票:**
        - `create_pull_request` を実行し、以下の構成で PR を起票する。
            - **Title:** `docs(design): Design Doc XXX (機能名) の作成`
            - **Body:**
              ```markdown
              ## 概要
              (新機能の目的と期待されるアウトカムの要約)

              ## 主な設計内容
              (採用したアーキテクチャやデータモデルの核心部分)

              ## 実装への引き継ぎ事項
              (実装担当が特に注意すべき制約や、検証基準のポイント)
              ```
    3.  **完了定義:** PR が起票され、設計思想が公式な記録として提出された時点で、アーキテクトとしての本ユースケースを完了とする。


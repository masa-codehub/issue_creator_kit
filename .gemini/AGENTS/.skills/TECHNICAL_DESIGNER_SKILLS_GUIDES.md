# 開発標準の整備 (Standardization)

開発チームの生産性とコード品質を向上させるためのガイドラインやルールを策定・文書化するプロセスです。単なる「文書化」ではなく、ツールの設定（Linter等）や既存コードの実態と整合した「生きたガイド」を維持します。

### Step 0: インプットと実態の把握 (Observe)

1.  **担当Issueと依存関係の確認:**
    1.  `issue_read(method="get", issue_number=XXX)` を実行し、標準化の目的（手戻りの防止、品質向上、技術選定の共有など）を明確にする。
    2.  `issue_read(method="get_sub_issues", issue_number=XXX)` を使い、依存タスクが全て **CLOSED** になっていることを確認する。
    3.  標準化が ADR の実装である場合、関連する `reqs/design/_approved/adr-XXX.md` を読み込む。

2.  **作業ブランチの準備:**
    1.  **ベースブランチの特定:** 担当Issueの記述（本文やコメント）を確認し、作業の基点となる「ベースブランチ」の指定がないか確認する（明示がなければ `main` をベースとする）。
    2.  **ベースの最新化:** `run_shell_command("git checkout <base_branch> && git pull")` を実行し、ベースブランチをリモートの最新状態に同期する。
    3.  **作業ブランチの作成:** `create_branch` (または `git checkout -b`) を使用し、Issue番号を含んだ作業用ブランチ（例: `feature/guide-update-issue-XXX`）をベースブランチから作成する。

3.  **既存ルールとツールの調査:**
    1.  **ドキュメント調査:** `list_directory(dir_path="docs/guides/")` と `read_file` で既存ガイドを確認し、情報の重複や矛盾をチェックする。
    2.  **ツール設定の調査:** `read_file` で `pyproject.toml`, `.pre-commit-config.yaml`, `tsconfig.json` 等の設定ファイルを読み込み、既にツールで自動化（強制）されているルールを特定する。
    3.  **コード実態の調査:** `search_code` や `glob` を使い、現状のコードベースで守られている（または破られている）「暗黙の慣習」をサンプリング調査する。

4.  **課題の定義とギャップ分析:**
    1.  Issueの要求、Step 0-3 の調査結果に基づき、解決すべき課題を定義する。

    **分析結果アウトプット例（作業ログ）**
    ```markdown
    ## ギャップ分析レポート
    - **課題:** PRでの例外ハンドリングの指摘が頻発しており、レビューコストが高い。
    - **現状:** `docs/guides/coding-guidelines.md` には一般的なことしか書かれておらず、プロジェクト固有の `AppException` の使い分けが不明確。
    - **ツール状況:** Linterでは例外の種類まではチェックできない。
    - **対応方針:** プロジェクト固有の例外ハンドリングガイドラインを追記し、具体例（Good/Bad）を示す。
    ```

### Step 1: ルールの策定とドラフト作成 (Orient)

現状分析に基づき、**「実現可能で、かつチームの納得感が高い」** ルールを設計し、ドラフトを作成します。

1.  **ルール方針の策定:**
    - **自動化の検討:** そのルールは `ruff`, `mypy`, `eslint` 等で自動チェック可能か？ 可能ならガイド記述よりツール設定の変更を優先する。
    - **トレードオフ検討:** そのルール導入による「実装コスト増」と「品質・保守性向上」のバランスを評価する。

2.  **具体的ルールの記述 (Drafting):**
    - 抽象的な表現（「綺麗に書く」など）を避け、具体的な **Do/Don't** を定義する。
    - 誰が実行しても同じ結果になるよう、必要な **コマンド例や設定例** を記述する。

    **アウトプット例**
    ```markdown
    ### ルール案: 非同期処理のタイムアウト設定
    - **ルール:** 全ての外部API呼び出しには、明示的な `timeout` を設定しなければならない。
    - **Good:** `requests.get(url, timeout=5.0)`
    - **Bad:** `requests.get(url)` (デフォルトの無限待機は禁止)
    - **理由:** 外部サービスの遅延がシステム全体のスレッド枯渇を招くのを防ぐため（参考: ADR-012 Resiliency）。
    ```

3.  **ガイドドラフトの作成:**
    1.  `docs/guides/` 配下の適切なファイルを選択、または新規作成する。
    2.  既存のスタイルガイドがある場合は、その構造（目次など）を維持しつつ追記する。
    3.  `write_file(file_path="docs/guides/xxx.md")` を実行してドラフトを保存する。

### Step 2: 自己レビューとドキュメントの最終化 (Act)

作成したガイドを客観的に検証し、公式ドキュメントとして反映・公開します。

1.  **ドラフトと基準情報の読み込み:**
    1.  `read_file` を使用して作成したドラフトを読み込む。
    2.  **基準情報の再確認:** 検証の基準として、以下を再確認する。
        - 担当Issue: `issue_read`
        - 関連ADR: `read_file(file_path="reqs/design/_approved/adr-XXX.md")`
    3.  **実行可能性の検証:** ガイドに記載したコマンド例等が、現在の環境で実際に動作するか（パスやオプションが正しいか）を再確認する。

2.  **自己レビュー (Self-Review):**
    1.  以下の **「ガイド品質チェックリスト」** に基づいて検証を行う。

    **ガイド品質チェックリスト**
    - [ ] **具体的・客観的:** 曖昧な表現がなく、誰が読んでも同じ解釈ができるか？
    - [ ] **Why（背景）の明記:** なぜそのルールが必要なのか、メリットが説明されているか？
    - [ ] **具体例の提示:** Good/Bad のコード例や、実際のコマンド例が含まれているか？
    - [ ] **保守性:** ツール設定（Linter等）や既存コードの実態と矛盾していないか？
    - [ ] **構造化:** 目次や見出しが適切で、目的の情報に素早くアクセスできるか？

3.  **ドキュメント・設定の更新と Git 反映:**
    1.  `write_file` または `replace` を使用して、対象となるガイドドキュメント（および変更が必要な場合はツール設定ファイル）を正式に更新する。
    2.  **成果物の記録:** `run_shell_command` を使い、`git add`, `git commit -m "docs: update development guide for [項目名]"`, `git push` を実行する。
    3.  **PRの作成:** `create_pull_request` で、ルールの変更意図を明示したプルリクエストを作成する（既にPRが存在する場合は不要）。

4.  **完了報告とハンドオフ:**
    1.  担当Issueにコメントし、更新内容とPRのURLを報告する。
    2.  **チームへの共有:** 必要に応じて、開発チャネル等で新しいルールの運用開始をアナウンスするよう、依頼者（PM等）に促す。
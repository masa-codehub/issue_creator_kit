# スキル: コードレビューへの対応 (Skill: Code Review Response)

提出したプルリクエスト(PR)に対してレビュアーから受けた指摘や質問を分析し、コードの修正または技術的な根拠に基づいた回答を行うための標準プロセスです。

### Step 1: レビュー内容の分析 (Observe & Orient)

1.  **コンテキストの確立と全件把握:**
    - `pull_request_read(method="get_review_comments")` 等を実行し、全ての指摘事項を取得する。
    - 指摘が「どのファイル」の「どのシンボル（関数/クラス）」に向けられたものかリストアップする。

2.  **指摘箇所と最新コードのマッピング:**
    - PR上の行番号は古い可能性があるため、`search_file_content` や `read_file` を使用して、**最新のファイル内での正確な位置（コンテキスト）**を特定する。
    - 指摘箇所の前後 5〜10 行を読み込み、レビュアーが見ているコードと現状のコードに乖離がないか確認する。

3.  **関連 SSOT の選定と調査:**
    - 修正対象のレイヤーに応じて、参照すべき SSOT を絞り込み、`read_file` で読み込む。
        - **Domain/UseCase 層:** `reqs/design/_approved/adr-xxx.md`, `docs/specs/` のロジック定義。
        - **Interface/Infrastructure 層:** `docs/specs/interface-spec.md`, 外部連携仕様。
    - 指摘が SSOT（プロジェクトの合意事項）に反していないか、または SSOT の解釈違いによるものかを確認する。

4.  **価値の特定とリスク分析 (Quantitative Check):**
    - **重要度の分類:** 軽微な修正（タイポ等）は価値定義をスキップし無駄を省く。設計やロジックに関する指摘のみ「ユーザー価値 (User-Value First)」を言語化する。
    - **定量的リスク評価:** 修正範囲のファイルサイズ（300行超か）、ネストの深さ、既存テストの有無を確認し、修正によるデグレードリスクを A/B/C でランク付けする。

5.  **環境の最新化と同期 (Synchronize):**
    - `run_shell_command` を使用して、ベースブランチの最新化と作業ブランチへの `rebase` を実行する。
    - **同期後の再確認:** `rebase` によってコード位置が大きく変わった場合は、再度 `read_file` で修正箇所を確認する。

6.  **対応方針の決定:**
    - 指摘1件ごとに以下のマトリクスに基づいて方針を決定し、ログに出力する。

    | 方針 | 処置 | 判断基準・例 |
    | :--- | :--- | :--- |
    | **受諾 (Accept)** | コードを修正し、テストをパスさせる | タイポ、明らかなバグ、プロジェクト規約違反、正当な可読性向上提案 |
    | **議論 (Discuss)** | 質問または代替案をコメントし、合意を形成する | 指摘の意図が不明、修正による副作用の懸念、より良い別解の提示 |
    | **根拠の提示 (Explain)** | **修正は行わず**、設計根拠やSSOTを引用して説明する | SSOT(ADR/Specs)との矛盾、意図的な設計選択（トレードオフ）、的外れな指摘 |

    **アウトプット例 (Review Analysis Result):**
    ```markdown
    ### レビュー指摘の分析結果
    1. **指摘内容:** "変数名 `x` は意味不明なので `retry_count` に変更してください"
       - **対応方針:** **受諾 (Accept)**
       - **処置:** 指摘通りリネームを実施し、関連する全テストのパスを確認する。
    2. **指摘内容:** "この認証ロジックは Infrastructure レイヤーに記述すべきではないか？"
       - **対応方針:** **根拠の提示 (Explain)**
       - **処置:** 修正は行わない。承認済み ADR-001 にて「認証の抽象化は Domain レイヤーで行う」と定義されているため、現状の実装が正当であることを SSOT を引用して回答する。
    3. **指摘内容:** "ここを非同期処理にすると高速化できる"
       - **対応方針:** **議論 (Discuss)**
       - **処置:** 高速化のメリットは認めるが、現在の基盤が非同期未対応であることを伝え、今後のロードマップとして提案するかどうかを確認する。
    ```

### Step 2: 修正計画の策定 (Plan)

1.  **修正計画 (Review Fix Plan) の作成:**
    - 指摘規模に応じて計画を作成する。**10行以上のロジック変更を伴う場合は以下の表形式を使用し、軽微な修正（タイポ・1行の変更）は箇条書きでの簡略化を許容する。**
    - **制約:** 計画段階で「修正すべきテストファイル」を必ず特定する。

    | 項目 | 内容 |
    | :--- | :--- |
    | **[Target] 対象** | 修正対象のファイルパス、シンボル。 |
    | **[Test Target] テスト** | **Redテストを記述するテストファイルパス。**（新規作成か既存追記か） |
    | **[Architecture] 境界** | 修正レイヤーと、**新たに import するモジュールの正当性**（依存ルール違反がないか）。 |
    | **[As-Is/To-Be] 概要** | 現状の問題点と、修正後の理想的なコード構造。 |
    | **[Steps] 手順** | 1. Redテスト作成、2. 実装、3. **修正スコープ内の**クリーンアップ（ボーイスカウト）、4. 検証。 |
    | **[Contingency] 撤退** | 既存テストが N 件以上失敗、またはレイヤー違反が不可避となった場合の撤退基準。 |

    **アウトプット例 (Review Fix Plan):**
    ```markdown
    ## Review Fix Plan
    - **[Target]:** `src/domain/user.py` の `User.change_email`
    - **[Test Target]:** `tests/unit/test_user.py` (既存追記)
    - **[Architecture]:** Domain層。外部ライブラリの直接依存を避け、組み込み型のみを使用する。
    - **[As-Is/To-Be]:** ロック中のメール変更が許可されている。ガード節を追加して `AccountLockedError` を投げるようにする。
    - **[Steps]:** 1. `test_cannot_change_email_when_locked` を Red で追加、2. 実装、3. 同メソッド内の不要なコメントを削除、4. 実行。
    - **[Contingency]:** 既存の `test_user_flow` が壊れ、修正に 15 分以上かかる場合は設計を見直す。
    ```

2.  **計画の整合性・網羅性チェック:**
    - 作成した計画を以下の観点でセルフチェックし、結果をログに出力する。
        - **SSOT整合性:** 指摘への対応が、ADR や仕様書の根本的な設計原則を破壊していないか？
        - **スコープの限定:** ボーイスカウト・ルールが、**今回修正するメソッド/関数外**にまで及んでいないか？（PRのノイズ防止）
        - **テストの適切性:** 選択した [Test Target] は、ロジックを検証するのに最適なレイヤーか？
        - **ユビキタス言語:** 命名修正がプロジェクトの用語集と完全に一致しているか？

### Step 3: 修正の実装と検証 (Act & Verify)

1.  **項目の逐次処理 (TDD & Boy Scout):**
    - Step 1 でリストアップした「受諾 (Accept)」項目を上から順に 1 件ずつ処理する。
    - **TDD の徹底:** `pytest <file_path>::<test_name>` を使用し、**作成したテストケースのみ**をピンポイントで実行して Red/Green を確認する。
    - **ボーイスカウトの物理制限:** クリーンアップは、**今回修正するメソッド/関数の範囲内**に限定する。PR の Diff を無駄に広げない。

2.  **効率的なコード操作:**
    - `replace` を使用して修正する。Step 2 の計画時のコンテキストで `old_string` が特定できる場合は、無駄な `read_file` をスキップして良い。
    - **YAGNI チェック:** 修正完了直後に、指摘と無関係な「将来への備え」や過剰な抽象化が混入していないか最終確認する。

3.  **三振ルールと仮説の転換:**
    - ピンポイントテストが 2 回連続で失敗した場合、即座に作業を中断する。
    - **自己対話のログ出力:** なぜ失敗したか、現在の設計のどこに無理があるかを 1 文でログに出力し、別のアプローチ（SSOT への立ち返り）を宣言する。

4.  **1項目 1コミットの原則:**
    - **原則として、Step 1 の 1 項目ごとにコミットする。** これにより、一部の修正が却下されても Revert が容易になる。
    - `run_shell_command("git add . && git commit -m 'fix(review): [Symbol Name] - [Summary of change]'")`
    - **進捗の記録:** コミット完了後、エージェントのメモリ（Todoリスト等）で当該項目を `[x]` に更新し、ユーザーに残件を報告する。

### Step 4: 品質保証と完了 (Verify & Finalize)

1.  **プロジェクト全体の最終ゲート (Token Efficient):**
    - プッシュ前に全修正の整合性を確認する。
    - **検証の実行:** `run_shell_command("pytest -q --tb=short")` 
        - ※ 出力トークンを節約するため、詳細なログ (`-s`) は避け、サマリーと失敗箇所のみを表示する。
    - **静的解析:** `run_shell_command("ruff check . && mypy .")`
    - **エラー時の復帰:** 万が一失敗した場合は、直ちに Step 3 の「三振ルール」に基づき、原因分析と修正（または Revert）をやり直す。

2.  **GitHub レビューワークフローの実行:**
    - 通知を最小限に抑え、レビュアーが一度に確認できるように以下の順序で実行する。
        1. **レビューの開始:** `pull_request_review_write(method="create")` で Pending レビューを作成する。
        2. **返信の追記:** 各指摘に対し `add_comment_to_pending_review` で回答する。
            - **根拠提示 (Explain) の際:** SSOT の該当箇所を引用し、レビュアーが資料を探す手間を省く。
            - **改善の報告:** ボーイスカウト活動を「付加価値」として簡潔に添える。
        3. **レビューの送信:** `pull_request_review_write(method="submit_pending", event="COMMENT", body="修正が完了しました。")` を実行し、一括で通知を送る。

3.  **最終プッシュと完了報告:**
    - `run_shell_command("git push origin <working_branch>")` を実行。
    - 最後に `add_issue_comment` で PR 全体のサマリー（完了した項目と残課題）を報告し、タスクを終了する。

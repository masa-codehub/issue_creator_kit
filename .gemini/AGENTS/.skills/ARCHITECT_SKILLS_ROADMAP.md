
承認済みの ADR または Design Doc（あるべき姿）を、稼働中のシステムを壊さずに実現するための「段階的な実装・修正手順」を設計するプロセスです。設計ドキュメントが「目的地」を定義していることを前提に、本ユースケースはそこへ至る「安全な着地ステップ」の策定のみに責任を持ちます。

### Step 0: 事前準備（承認済み設計の確認）

1.  **前提設計の読み込み:** `reqs/design/_approved/` 配下にある **承認済み** の ADR または Design Doc を `read_file` し、設計思想、データモデル、決定事項を完全に理解する。
2.  **作業ブランチの作成:** `run_shell_command(command="git checkout -b design/plan-XXX-feature-name")` を実行し、安全な作業環境を確保する。

### Step 1: 実装戦略の策定と不確実性の検証 (Observe & Orient)

1.  **テンプレートの取得:** `read_file(file_path="reqs/roadmap/template/migration-roadmap.md")` を実行し、計画書の構成を把握する。
2.  **不確実性と阻害要因の特定:**
    - **ドキュメントの再調査（観点の網羅と重点化）:** 
        1.  以下の観点リストから、今回の変更においてリスクが高い項目を評価し、重点チェック対象を特定する。
            - **[非機能要件]**: 性能・可用性・拡張性 (SLAとの整合)
            - **[運用・保守性]**: ログ監視・障害復旧・デプロイ要件
            - **[セキュリティ]**: 認証・認可・データ保護・監査
            - **[データ整合性]**: トランザクション境界・マイグレーション・整合性モデル
            - **[外部依存]**: APIレート制限・ライブラリサポート期限
            - **[UI/UX・用語]**: デザインガイドライン・ユビキタス言語の統一
            - **[法規制・廃止]**: コンプライアンス・廃止予定機能への依存
        2.  特定した重点項目について、`glob(pattern="docs/**/*.md")` および `glob(pattern="specs/**/*.md")` を実行し、ドキュメントを精査して新設計との矛盾がないか確認する。
    - **コードベースの精査 (発散と収束):** 
        1.  `search_file_content(pattern="<関連キーワード>", dir_path="src/")` を用い、設計の適用を阻害する既存実装や技術的懸念を網羅的にリストアップする。
        2.  各項目に「重要度」を付与し、計画に組み込むべき事項（Spike や Pre-refactor タスクの候補）をピックアップする。

**アウトプット例 (分析と選定):**
```markdown
### 阻害要因・懸念リストと対策方針
- **[高] 密結合:** `OrderService` が `StripeClient` を直接 `new()` しており、DI できない。
    - -> **対策:** Phase 1 にて `IPayment` インターフェース抽出と DI 化を Pre タスクとして実施。
- **[高] パフォーマンス:** 大量データ時の集計クエリの挙動が不明。
    - -> **対策:** Phase 1 の最初に Spike タスクを設け、1,000万件データでの負荷検証を行う。
- **[中] ライブラリ互換性:** `v2.0` が Python 3.8 で動くか未確認。
    - -> **対策:** 検証用スクリプトで動作確認を行うタスクを追加。
- **[低] 命名規則:** 変数名が古い規約のまま。
    - -> **対策:** 今回のリファクタリングスコープからは除外（WBSには積まない）。
```

3.  **実装戦略の定義 (Write):**
    - `write_file(file_path="reqs/roadmap/_inbox/roadmap-XXX-implementation.md", content="...")` でドラフトを作成し、安全な着地の「型（戦略）」を記述する。この際、Step 2 で特定した懸念に対する「調査タスク (Spike)」を計画の冒頭に組み込むことを検討する。ステータスは `作成中` とする。

### Step 2: 実装フェーズと標準カテゴリに基づく WBS 設計 (Orient)

1.  **戦略とフェーズの定義とWBSの展開:**
    - **戦略パターンの選択:** 以下の「3つの型」から案件に最適なものを選択する。
    - **フェーズの定義:** 選択した型に従い、Phase 1〜3 の「目的」と「成果物」を具体的に定義する。
    - **ブランチ戦略の定義 (Define Branching Strategy):**
        - **Phase Base Branch (Foundation):** 各フェーズの開始時（Setup Task）に、そのフェーズの基点となるブランチ（例: `feature/phase-X-foundation`）を作成する。これを当該フェーズにおける **ベースブランチ (Base Branch)** とする。
        - **Task Working Branch (Feature):** 各実装タスク（Issue）は、ベースブランチから派生した個別の **作業ブランチ (Feature Branch)** （例: `feature/task-ID-desc`）で実行する。
        - **Merge Flow:** 実装完了後は作業ブランチをベースブランチへマージし、フェーズ完了時（Review Task）にベースブランチを `main` へマージする流れを WBS に組み込む。
    - **WBS の展開:** 定義した各フェーズの直下に、以下の標準構造でタスクテーブル（WBS）を作成し、ロードマップの「## 2. 実装フェーズとWBS」を埋める。
        - **[先頭] Setup Task:** フェーズ用ベースブランチ（Foundation）の作成と環境準備。
        - **[中間] Implementation Tasks:** 具体的な実装・テスト・移行作業（Spike, Pre, Impl, Verify, Clean）。各タスクは固有の作業ブランチ（Feature Branch）で行われる。
        - **[末尾] Review Task:** フェーズ完了の承認（Gate チェック）と、ベースブランチの Main へのマージ。
        - **依存関係の明示:** 各タスクの「依存先 ID」および「外部チーム/APIへの依存」を特定し、クリティカルパスを明確にする。

**アウトプット例 (戦略パターン別のフェーズ定義):**
```markdown
### Phase 1: 設計とテスト要件の確定 (Design & Test Criteria)
- **Goal (狙い)**: 実装開始前に「あるべき姿」と「検証方法」を完全に一致させ、迷いと手戻りを排除する。
- **Input (前提)**: 承認済みの ADR/Design Doc。
- **Deliverables (成果物)**:
    - **検証基準リスト (Acceptance Criteria)**:
        - **目的**: 正常系・異常系・境界値を含む「成功の定義」をテストレベルで言語化し、実装時の不確実性を排除するため。
    - **インターフェース定義案 (Draft Interface)**:
        - **目的**: クラス名やメソッドシグネチャを机上で確定させ、実装者間の認識を統一するため。
- **Gate (承認条件)**: 上記の検証基準と定義案が、設計の意図を完全に網羅していると合意されること。

**WBS**
| Task ID | Category | タスク内容 | 対象ファイル | 依存先 | Issue案リンク |
| :---: | :---: | :--- | :--- | :---: | :--- |
| T1-1 | Setup | 作業ブランチ `feature/phase-1` の作成 | - | - | |
| T1-2 | Spike | 既存クラスの全依存関係を調査し、リスト化する | `src/legacy/service.py` | T1-1 | |
| T1-3 | Pre | 新インターフェース `IService` の定義作成 | `src/new/interface.py` | T1-2 | |
| T1-4 | Review | Phase 1 成果物のレビューと Phase 2 計画の確定 | - | T1-3 | |

### Phase 2: 疎結合化とアダプター適用 (Decouple & Adapter)
- **Goal (狙い)**: 既存コードを壊さずに「新旧差し替え可能な状態」を作り出し、安全な移行の足場を固める。
- **Input (前提)**: 確定した検証基準とインターフェース案。
- **Deliverables (成果物)**:
    - **`Interface` / `Adapter` とそのテスト**:
        - **目的**: 既存ロジックをラップして疎結合にし、新旧ロジックを安全に切り替え可能な状態にするため。
- **Gate (承認条件)**: 既存の自動テストが Adapter 経由で全てパスし、本番デプロイしても既存機能に影響がないこと。

**WBS**
| Task ID | Category | タスク内容 | 対象ファイル | 依存先 | Issue案リンク |
| :---: | :---: | :--- | :--- | :---: | :--- |
| T2-1 | Setup | 作業ブランチ `feature/phase-2` の作成と T1 のマージ | - | T1-4 | |
| T2-2 | Impl | 旧ロジックをラップする `LegacyAdapter` の実装 | `src/new/adapter.py` | T2-1 | |
| T2-3 | Verify | Adapter 経由で既存テストがパスすることを確認 | `tests/unit/test_adapter.py` | T2-2 | |
| T2-4 | Impl | クライアントコードの依存先を `IService` へ変更 | `src/client.py` | T2-3 | |
| T2-5 | Review | Phase 2 成果物のレビューと Phase 3 計画の確定 | - | T2-4 | |

### Phase 3: 新ロジック実装と並行稼働 (Implement & Shadowing)
- **Goal (狙い)**: 新ロジックの実効性を本番データで証明し、100% の信頼を得るまで検証を回す。
- **Input (前提)**: 疎結合化されたコードベース。
- **Deliverables (成果物)**:
    - **新ロジックの実装とその単体テスト**:
        - **目的**: 検証基準を満たす新しいビジネスロジックを確立するため。
    - **並行稼働（Shadowing）の実装**:
        - **目的**: ユーザーに影響を与えずに、本番データを用いて新旧ロジックの出力を比較検証するため。
- **Gate (承認条件)**: 新ロジックのテストがパスし、並行稼働ログにおいて新旧の出力不一致が 0 件であること。

**WBS**
| Task ID | Category | タスク内容 | 対象ファイル | 依存先 | Issue案リンク |
| :---: | :---: | :--- | :--- | :---: | :--- |
| T3-1 | Setup | 作業ブランチ `feature/phase-3` の作成と T2 のマージ | - | T2-5 | |
| T3-2 | Impl | 新ロジック `NewService` の実装 | `src/new/service.py` | T3-1 | |
| T3-3 | Impl | 新旧比較を行う `ShadowingProxy` の実装 | `src/new/proxy.py` | T3-2 | |
| T3-4 | Verify | 本番ログによる出力一致率の検証 | - | T3-3 | |
| T3-5 | Review | Phase 3 成果物のレビューと Phase 4 計画の確定 | - | T3-4 | |

### Phase 4: 切り替えと負債の清算 (Release & Refactor)
- **Goal (狙い)**: 安全にバトンを渡し、古い資産を物理的に排除してシステムを健全化する。
- **Input (前提)**: 検証済みの新ロジック。
- **Deliverables (成果物)**:
    - **本番構成の切り替え**:
        - **目的**: ユーザーに新ロジックの価値（性能向上等）を提供するため。
    - **旧コードの削除コミット**:
        - **目的**: 技術的負債を清算し、保守コストを下げるため。
- **Gate (承認条件)**: 旧コードが消滅し、全テストスイートがグリーンであること。

**WBS**
| Task ID | Category | タスク内容 | 対象ファイル | 依存先 | Issue案リンク |
| :---: | :---: | :--- | :--- | :---: | :--- |
| T4-1 | Setup | 作業ブランチ `feature/phase-4` の作成と T3 のマージ | - | T3-5 | |
| T4-2 | Impl | DI コンテナの設定変更（NewServiceへの切り替え） | `src/config/container.py` | T4-1 | |
| T4-3 | Verify | リグレッションテストの実行 | - | T4-2 | |
| T4-4 | Clean | 旧コード `legacy/` および `LegacyAdapter` の削除 | `src/legacy/` | T4-3 | |
| T4-5 | Review | 最終成果物のレビューとロードマップ完了承認 | - | T4-4 | |
```

2.  **インパクトの評価:** 以下のテンプレートを思考プロセスの冒頭に出力し、評価結果に基づき `replace` でロードマップの「## 3. リスク管理とロールバック」を埋める。

**実装・リファクタリング計画 4 大リスク評価**
```
[価値: 評価(高/中/低)] 計画の各ステップが、早期に部分的な価値（動作確認等）を提供できるか？
[実現可能性: 評価(高/中/低)] 既存のビジネスロジックを維持したまま、段階的に適用可能か？
[ユーザビリティ: 評価(高/中/低)] 実装途中の「新旧混在状態」が、開発者の混乱を招かないか？
[ビジネス生存性: 評価(高/中/低)] データ破損やダウンタイムのリスクは許容範囲か？リセット手順はあるか？
```

### Step 3: Issue 案の作成 (Drafting)

1.  **テンプレートの取得:** `read_file(file_path="reqs/tasks/template/issue-draft.md")` を実行する。
2.  **Issue 案のファイル出力 (Agent-Ready):** Step 2 で設計した WBS に基づき、以下の3種類の Issue 案を作成する。
    - **A. Phase 開始 Issue (Setup):**
        - 各フェーズの冒頭に配置。ベースブランチ（Foundation, 例: `feature/phase-1-setup`）の作成と、後続タスクへのブランチ共有を指示する。
    - **B. 実装タスク Issue (Implementation):**
        - WBS の各タスクに対応。`write_file(file_path="reqs/tasks/drafts/issue-XXX-T1.md", content="...")` として作成する。
        - **1タスク1Issueの原則:** WBS で定義したタスク1つにつき、必ず1つの Issue ファイルを作成する。複数のタスクを1つの Issue にまとめてはならない。
        - **ブランチ戦略 (Branching Strategy):** テンプレートに従い、以下を明記する。
            - **Base Branch:** そのフェーズの Foundation Branch (例: `feature/phase-X-foundation`)
            - **Feature Branch:** タスク固有の作業ブランチ (例: `feature/task-ID-desc`)
        - **必須項目:** 参照パス、検証コマンド、依存ブランチ名。
    - **C. Phase 完了 Issue (Review & Plan):**
        - 各フェーズの末尾に配置。全タスクの完了確認、成果物の検証（Gate チェック）、および**ベースブランチの Main へのマージ**を指示する。
    - **共通ルール:** GitHub への直接起票は行わず、すべてファイルとして SSOT に残すこと。
3.  **Issue 内容の自己レビュー (Cross-Check):**
    - 作成した Issue ファイルと、ロードマップの WBS セクションを **両方 `read_file` で読み込み**、以下のチェックリストで整合性を確認する。
        - **[ID整合性]**: Issue ファイル名とロードマップ上のタスク ID は一致しているか？
        - **[依存関係]**: Issue 内の「前提条件（Prerequisites）」は、WBS の依存タスクと矛盾していないか？
        - **[参照パス]**: 指定した ADR や Design Doc のパスは正確で、リンク切れしていないか？
        - **[検証コマンド]**: 「テストを実行する」等の曖昧な表現ではなく、`pytest tests/unit/test_auth.py` のようにコピペで実行可能なコマンドが記述されているか？
        - **[完了条件]**: WBS で定義した「成果物」が、Issue の完了条件として網羅されているか？
4.  **計画へのリンク追記:** チェック完了後、`replace` を用いて `reqs/roadmap/_inbox/roadmap-XXX-implementation.md` の WBS テーブルに各 Issue 案ファイルへのリンクを追記する。

### Step 4: ユーザーとの合意形成ループ (Decide)

作成した実装計画（ロードマップ）および詳細な Issue 案に基づき、スピードと安全性のトレードオフや、具体的な実装指示の内容についてユーザーと合意形成を行います。全ての論点が解消されるまで、以下の **「合意形成ループ」** を回し続けます。

1.  **論点（質問リスト）の初期化:**
    - ロードマップ全体の方針に加え、**作成した Issue 案（指示書）の粒度や検証基準**に不足がないかを確認事項としてリストアップする。
    - `save_memory` を用いて、解決すべき項目を記録する。
    - **主な論点例:**
        - **WBS/スケジュールの妥当性:** 並行稼働期間やロールバック基準。
        - **Issue の具体性:** 実装者が迷わないレベルまで参照ファイルや検証コマンドが記載されているか。
    - **コマンド例:** `save_memory(fact="[Roadmap-XXX] 論点TODO: 1.Issue-T1の検証コマンドが具体的か確認...")`

2.  **合意形成ループの実行:**
    - **A. 最小単位の問いかけ:**
        - **TODO の呼び出し:** `save_memory` に記録した論点から優先度の高い項目を選択する。
        - **詳細の提示:** 必要に応じて Issue ファイルの中身を提示し、「この指示内容で実装エージェントが自走できるか」という視点で確認を求める。
    - **B. 計画・Issue の同期と提示:**
        - ユーザーの回答に基づき、`roadmap` や `issue` ファイルを `replace` で即座に修正する。
        - **更新の明示:** 修正箇所を要約して提示する。
    - **C. リストの更新:** 解決した論点を削除し、新たな疑問があれば `save_memory` に追加する。

3.  **ループの終了（完了判定）:**
    - `save_memory` 内の全ての論点が解消され、ロードマップおよび全 Issue 案の内容に対してユーザーと合意・確信を共有できた時点で、このフェーズを完了とする。
    - **ステータスの更新:** `replace` を用い、ロードマップの `Status` を `作成中` から `承認済み` に変更する。
    - **最終監査と PR 起票:** 計画および Issue 案群を含む PR を起票する。
    - **メモリのクリーンアップ:** 完了にあたり、`save_memory(fact="[Roadmap-XXX] 論点TODO: (全て解消・完了)")` を実行する。

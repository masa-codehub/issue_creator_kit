# スキル: Issue 案の作成 (Issue Drafting)

**承認済みのロードマップに基づき、実装エージェントが一点の疑念もなく TDD プロセスを完遂可能な「タスク指示書（Draft Issue）」を構築するプロセスです。**

---

## 0. タスク選定 (Task Selection)

作業に着手する前に、必ず「今、何をすべきか」をアクティブなロードマップから特定します。

1.  **ソースの確認**: `reqs/roadmap/active/` 内にあるロードマップファイルを確認する。
2.  **次タスクの特定**: 現在のフェーズを確認し、未着手の中で最も優先度が高い（または依存関係の上流にある）タスク ID（例: T1-1）を選択する。
3.  **Draft ディレクトリの準備**: `reqs/tasks/drafts/<ADR-ID>/<Phase>/` ディレクトリが存在しない場合は作成する。

---

## 1. 精密記述プロトコル (Precision Guardrails)

エージェントが迷わず、かつ正確に目的を達成するために、以下の要素を具体的に記述します。

### 1.1 成果物と負の制約 (Positive & Negative Constraints)
*   **Artifact**: 1 タスク 1 成果物の原則を維持し、DoD を客観的に記述する。
*   **Constraints**: 「やってはいけないこと」を明文化し、AI の副作用を封じ込める。
    - 例: 「既存の `Adapter` のメソッドシグネチャは変更禁止」「XX ファイル以外のリファクタリングは本タスクのスコープ外」

### 1.2 参照コンテキストの網羅 (Context Scrutiny)
*   エージェントが `read_file` すべきファイルを最小かつ過不足なくリストアップする。
    - 準拠すべき `interface.py`、比較対象の `existing_logic.py`、土台となる `test_base.py` 等を特定する。

### 1.3 証拠（Evidence）と TDD の紐付け
*   **Evidence**: 実装手順（Step-by-Step）は、必ず **詳細設計書（Design Doc）の具体的なセクション（第 X.X 項等）と対応** させる。
*   **TDD Traceability**: 検証手順に、対応する `Acceptance Criteria ID`（例: TC-001）を明記する。
    - Phase 1 完了前はプレースホルダ（`TC-TBD`）とし、Phase 1 完了時の「Issue 再洗練タスク」で確定 ID を反映させる。

### 1.4 観測可能性と次フェーズへの連鎖 (Observability & Chaining)
*   **Observability**: 「テストが通る」だけでなく、期待されるログ出力やファイル状態を記述する。
*   **Next Phase Trigger**: **フェーズ最後のタスク（Review & Merge）** には、次フェーズを自動起動するためのマーキングを Frontmatter に付与します。
    - `next_phase_path`: 次フェーズのタスク群が待機している `drafts/` 内のパス（例: `reqs/tasks/drafts/adr-003/phase-2/`）。
    - *Role*: この Issue が `main` にマージされた瞬間、ICK はこのパスを読み取り、自動的に次フェーズの移動 PR を作成します。

---

## 2. ブランチ戦略 (Phase-Based Branching Strategy)

フェーズ内の位置に応じて、テンプレートのブランチ項目を以下の通り指定します。
1.  **フェーズ最初のタスク (Setup)**: Base: `main` / Feature: `feature/phase-X-foundation`
2.  **フェーズ途中の実装タスク**: Base: `feature/phase-X-foundation` / Feature: `feature/task-ID-desc`
3.  **フェーズ最後のタスク (Merge)**: Base: `feature/phase-X-foundation` / Feature: `main` (マージ作業)

---

## 3. 徹底監査プロセス (Iterative Scrutiny Loop)

`~/.gemini/GEMINI.md` の品質保証プロトコルに基づき、以下の「問いと回答」による監査を、疑念がゼロになるまで繰り返します。

### 3.1 個別精査質問票 (Per-Issue Questionnaire)
全 Issue に対し、以下の 5 つの問いを自問自答します。**回答には必ず具体的な「証拠（ファイル名、パス、引用）」を含めてください。**

1.  **[コンテキスト]**: 実装者は、指定された `Input Context` 以外のファイルを 1 つも開かずに実装を完了できるか？
    - *判定基準*: 回答が「できるはず」等の抽象的な場合は不合格。足りないファイルパスを特定し修正項目へ。
2.  **[証拠紐付け]**: 実装手順の各ステップは、詳細設計書のどの項目に対応しているか？
    - *判定基準*: 対応する「第 X.X 項」の記述が具体的でない場合は不合格。
3.  **[負の制約]**: 「やってはいけないこと」が、AI エージェントの代表的な暴走（余計なリファクタリング、ライブラリ追加）を封じ込めているか？
    - *判定基準*: 具体的な禁止対象ファイルやメソッドが指定されていない場合は不合格。
4.  **[観測可能性]**: テスト成功/失敗時に「何が起きるか（ログ、ファイル状態）」を目視確認できる手順が含まれているか？
    - *判定基準*: `pytest` 実行のみの記述は不合格。期待されるログメッセージ等を追記。
5.  **[ブランチ]**: 指定されたベースブランチは、先行タスクのマージ先と矛盾していないか？
    - *判定基準*: ブランチ名が不整合な場合は即座に修正項目へ。
6.  **[次フェーズ着火]**: フェーズ最後のタスク（Review）の場合、`next_phase_path` が正しく設定されているか？
    - *判定基準*: 最終タスクなのにパスが未指定、またはパスが間違っている場合は不合格。

### 3.2 全体整合性監査 (Cross-Issue Synthesis)
全 Issue を一つのシステムとして、以下のマトリクスチェックを行います。
*   **成果物のバトン**: タスク A の `Artifact`（成果物）が、タスク B の `Input Context`（入力）に漏れなく含まれているか？
*   **依存の鎖**: `depends_on` のリストが、ロードマップの WBS と完全一致しているか？
*   **情報の重複**: 前後の Issue で同じ説明を繰り返していないか？（共通事項は設計書への参照に集約されているか？）

### 3.3 修正と再監査のアルゴリズム
1.  **監査実行**: 上記の問いに対して、脳内で具体的な回答を生成する。
2.  **不備のリストアップ**: 回答が具体的でない、または矛盾がある箇所を「修正項目リスト」として書き出す。
3.  **一括修正**: リストに基づき、Issue ファイルを更新する。
4.  **再監査**: 修正後のファイルに対し、Step 1（3.1 個別精査）に戻って監査を再試行する。
5.  **完了宣言**: 全ての問いに対して「具体的な証拠を伴う合格回答」が得られた時のみ、監査を完了する。

---

## 4. 投入プロトコル (Promotion)

監査（Section 3）を完全にパスした Draft Issue を、仮想キュー（archive への移動 PR）を通じて起票します。

1.  **アーカイブへの移動**: Draft ファイルを `reqs/tasks/drafts/...` から `reqs/tasks/archive/...` 内の適切なディレクトリへ移動する。
    *   *コマンド例*: `run_shell_command{command: "mkdir -p reqs/tasks/archive/adr-xxx/phase-1 && mv reqs/tasks/drafts/adr-xxx/phase-1/issue-T1-1.md reqs/tasks/archive/adr-xxx/phase-1/"}`
2.  **PR作成**: 移動した変更を含むプルリクエストを作成する。
    *   **Title**: `feat: promote task <Task-ID> to archive`
    *   **Review**: このPRがマージされた瞬間、GitHub Issue が自動起票される。